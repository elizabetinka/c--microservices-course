# Лабораторная 1

## Задание 1

### Отрабатываемый материал

Основы .NET, генераторы, IEnumerable, IAsyncEnumerable, IEnumerator, IDisposable

### Задача

Реализовать метод расширения над `IEnumerable`, выполняющий операцию "склейки коллекций". Метод должен работать
аналогично методу `Zip` из LINQ, но, в отличие от него, метод, реализуемый вами должен принимать нефиксированное
количество "склеиваемых коллекций" (с использованием конструкции `params`).

Также необходимо реализовать такой же метод для `IAsyncEnumerable`. (В реализации данного метода разрешается
использование пакета `System.Linq.Async`).

### Функциональные требования

- Передача "других" коллекций для склейки через `params`
- Работа с коллекциями, имеющими одинаковый тип элемента

### Нефункциональные требования

- Коллекции, являющиеся входными параметрами должны иметь тип `IEnumerable<T>`/`IAsyncEnumerable<T>` (за исключением
  параметра с params)
- Реализация должна корректно утилизировать ресурсы
- Реализация должна обрабатывать ситуации когда переданы коллекции различной длины (выбор конкретной обработки –
  остаётся за вами)
- Тесты должны быть написаны на фреймворке XUnit с использованием библиотеки FluentAssertions

### Тестовые сценарии

#### Сценарий 1

**Arrange**

Методы Zip и ZipAsync вызываются на коллекции, не передавая ничего как аргумент.

**Assert**

Элементы результирующей коллекции должны быть коллекциями, содержащими единственный элемент из изначальной коллекции.

#### Сценарий 2

**Arrange**

Методы Zip и ZipAsync вызываются с различным количеством коллекций, длина которых равна длине коллекции, на которой
вызывается метод.

> Данный тест должен быть реализован как Theory, с использованием MemberData

#### Сценарий 3

**Arrange**

Методы Zip и ZipAsync вызываются с различным количеством коллекций, длина которых не равна длине коллекции, на которой
вызывается метод.

**Assert**

Результат операции должен соответствовать той обработке, что вы выбрали в реализации методов

> Данный тест должен быть реализован как Theory, с использованием MemberData

## Задание 2

### Отрабатываемый материал

async/await, TaskCompletionSource, CancellationToken

### Задача

Реализовать клиент-обёртку, поддерживающую async/await над сервисом, поддерживающим "реактивный" подход к реализации
асинхронного взаимодействия.

Предположим мы имеем какую-то стороннюю библиотеку, которую необходимо интегрировать в наш код. Библиотека выполняет
достаточно долгие операции, по этой причине имеет реактивный способ интеграции – мы можем инициировать какую-либо
операцию, а потом реализация библиотеки может отправить нам результат. Разработчики данной библиотеки не были знакомы с
концепциями async/await, поэтому предоставляют следующие интерфейсы:

```csharp
public sealed record RequestModel(string Method, byte[] Data);
```

```csharp
public sealed record ResponseModel(byte[] Data);
```

```csharp
public interface ILibraryOperationService
{
    void BeginOperation(Guid requestId, RequestModel model, CancellationToken cancellationToken);
}
```

```csharp
public interface ILibraryOperationHandler
{
    void HandleOperationResult(Guid requestId, byte[] data);

    void HandleOperationError(Guid requestId, Exception exception);
}
```

Интерфейс `ILibraryOperationService` реализован самой библиотекой, он используется, для того чтобы запустить в ней
какую-либо операцию. Интерфейс `ILibraryOperationHandler` же, должен быть реализован вами, его будет использовать
библиотека, для того чтобы реактивно отправлять результаты операций, которые могут быть как успешные, так и нет.

Такой механизм взаимодействия не особо удобен, концепция async/await позволяет писать код, выполняемый асинхронно в
синхронном стиле и сильно упрощает когнитивную сложность при чтении кода. Поэтому вам необходимо будет реализовать
интерфейс, позволяющий вызывать операции данной библиотеки в стиле async/await.

```csharp
public interface IRequestClient
{
    Task<ResponseModel> SendAsync(RequestModel request, CancellationToken cancellationToken);
}
```

Соответственно, вам необходимо написать класс, реализующий как интерфейс `IRequestClient`, так и интерфейс
`ILibraryOperationHandler`.

### Нефункциональные требования

- Реализация должна поддерживать многопоточное выполнение кода (несколько потоков могут как вызывать операцию, так и
  отдать её результат)
- Реализация должна быть устойчивой к различным race condition, например
    - Операция выполняется библиотекой быстро, ещё до окончания вызова метода `BeginOperation`
    - Операция отменяется быстро, ещё до вызова метода `BeginOperation`
- Реализация должна корректно поддерживать отмену. Подразумевается, что реализация библиотеки её поддерживает, и
  в случае когда операция отменяется не пришлёт результат операции. В таком случае вызов метода `SendAsync` не должен
  приводить к бесконечному ожиданию.
- Тесты должны быть написаны на фреймворке XUnit с использованием библиотеки FluentAssertions

### Тестовые сценарии

Для реализации тестов вам понадобится мок `ILibraryOperationService`, для этого необходимо воспользоваться библиотекой
NSubstibute.

#### Сценарий 1

Вызывается метод `SendAsync`, через какое-то время вызывается метод `HandleOperationResult`, при авейте таски,
полученной из `SendAsync` вы получаете переданный в хендлер результат.

#### Сценарий 2

Вызывается метод `SendAsync`, через какое-то время вызывается метод `HandleOperationError`, при авейте таски,
полученной из `SendAsync` должен быть выброшен экспешен, переданный в метод `HandleOperationError`.

#### Сценарий 3

Метод `SendAsync` вызывается с `CancellationToken`, который уже был отменён. При авейте таски, возвращённой методом,
должен быть выброшен `TaskCancelledException`.

#### Сценарий 4

Метод `SendAsync` вызывается с ещё не отменённым `CancellationToken`, через какое-то время токен должен быть отменён.
При авейте таски, возвращённой методом, должен быть выброшен `TaskCancelledException`.

#### Сценарий 5

Вызывается метод `SendAsync`, реализация `ILibraryOperationService`, переданная в класс, написанный вами, вызывает метод
`HandleOperationResult` прямо в методе `BeginOperation`. При авейте таски, полученной из `SendAsync` вы получаете
переданный в хендлер результат.

#### Сценарий 6

Вызывается метод `SendAsync`, реализация `ILibraryOperationService`, переданная в класс, написанный вами, вызывает метод
`HandleOperationError` прямо в методе `BeginOperation`. При авейте таски, полученной из `SendAsync` должен быть выброшен
экспешен, переданный в метод `HandleOperationError`.

#### Сценарий 7

Вызывается метод `SendAsync`, реализация `ILibraryOperationService`, переданная в класс, написанный вами, отмену
`CancellationToken` прямо в методе `BeginOperation`. При авейте таски, полученной из `SendAsync` должен быть выброшен
`TaskCancelledException`.

## Задание 3

### Отрабатываемый материал

Каналы, потоки, Parallel

### Задача

Реализовать систему обработки сообщений при помощи каналов. Предположим нем необходимо иметь возможность отсылать
какие-либо сообщения из нескольких потоков, но обрабатывать их в один поток несколькими обработчиками.

При наивной реализации (вызов обработчиков сообщений прямо при их отправке), каждому потоку, отправляющему сообщения,
будет необходимо ожидать выполнения обработки сообщений отправленных ранее, другими потоками. Такой подход имеет
несколько недостатков:

- Допустим потоки, отправляющие сообщения откуда-то их читают. В таком случае, если операция чтения сообщения
  выполняется значительно быстрее операции его обработки, мы будем значительно тормозить чтение
- Так как каждая обработка выполняется разрозненно, в отдельном потоке, что отправил сообщение, мы теряем возможность
  батчинга обработки, что также потенциально замедляет процесс, так как батчинг позволяет распределить накладные расходы
  при выполнении операций на несколько объектов.
- Мы имеем накладные расходы на синхронизацию потоков, что также тормозит чтение данных.

Поэтому нам необходимо разделить ответственность за запись сообщений и их обработку между разными потоками. И сделать
это мы можем при помощи каналов!

В рамках данного задания наша объектная модель будет состоять из нескольких типов:

```csharp
public record Message(string Title, string Text);
```

```csharp
public interface IMessageSender
{
    ValueTask SendAsync(Message message, CancellationToken cancellationToken);
}
```

```csharp
public interface IMessageProcessor
{
    Task ProcessAsync(CancellationToken cancellationToken);

    void Complete();
}
```

```csharp
public interface IMessageHandler
{
    ValueTask HandleAsync(IEnumerable<Message> messages, CancellationToken cancellationToken);
}
```

- `IMessageSender` – используется потоками, записывающими сообщения
- `IMessageProcessor` – используется потоком, обслуживающим очередь сообщений, а также потоком, управляющим циклом жизни
  вашей программы, останавливающим обработку
- `IMessageHandler` – реализует батчёвую обработку полученных сообщений.

`IMessageSender` будет реализован классом `MessageProcessor`, кроме метода отправки (записывающего сообщение в канал) он
должен
содержать метод `ProcessAsync`, который запускает чтение данных из канала и вызывает `IMessageHandler` для обработки
сообщений.

> Так как пакет `System.Linq.Async` не содержит метода аналогичного `Chunk` из обычного LINQ, вам необходимо будет
> воспользоваться методом расширения `ChunkAsync` из пакета `Itmo.Dev.Platform.Common`.

`IMessageHandler` реализует запись батча сообщений в консоль. В рамках данной лабораторной подразумевается, что
системные вызовы (представленные методом `Conole.WriteLine`) – дорогая операция, поэтому их необходимо минимизировать.
В реализации данного хендлера вы должны будете сначала собрать строку из всех сообщений и только потом писать её в
консоль.

### Нефункциональные требования

- Для реализации очереди обработки сообщений должны быть использованы каналы
- Реализация должна содержать батчинг сообщений
- Все значения, используемые в реализации (конфигурация канала, размер батчей, время таймаута батчинга, ...) должны быть
  параметризуемы
- В рамках метода `HandleAsync` вызов `Console.WriteLine` должен происходить единожды
- При попытке записи в заполненный канал, наиболее старые сообщения должны быть удалены из канала

### Тестовый сценарий

В рамках данной лабораторной вы должны будете подготовить тестовый сценарий в виде запускаемого консольного скрипта (
Program.cs).

В данном скрипте вам нужно будет:

- Создать объект `MessageProcessor`, передав в него консольный хендлер и распределить его на объекты двух разных типов

```csharp
var implementation = new MessageProcessor([new ConsoleMessageHandler()]);

IMessageProcessor processor = implementation;
IMessageSender sender = implementation;
```

- Запустить таску в "фоновом режиме" вызывав метод `ProcessAsync` у `IMessageProcessor`
- Используя метод `Parallel.ForEachAsync` создать некоторое количество сообщений и отправить их в `IMessageSender`
- После выполнения метода `Parallel.ForEachAsync` необходимо вызвать метод `Complete` в `IMessageProcessor`
- Далее необходимо заавейтить таску, которая была возвращена при вызове `ProcessAsync`

В итоге ваша программа должна вывести в консоль все сообщения и завершиться.

# Лабораторная 2

Для каждого задания необходимо создавать отдельный проект в соответствующей solution папке.

## Задание 1

### Отрабатываемый материал

Http, Refit

### Задача

Реализовать клиент для внешнего сервиса конфигураций, позволяющий выгрузку элементов конфигураций.

Реализация стороннего сервиса конфигураций находится в
репозитории [lab-2-tools](https://github.com/is-csms-y26/lab-2-tools), данный сервис заранее собран в Docker образ,
также в репозитории вы можете
найти [docker-compose](https://github.com/is-csms-y26/lab-2-tools/blob/master/docker-compose.yaml) файл, который
разворачивает сам сервис и базу данных для него. Вам необходимо скопировать этот файл в папку `scr/lab-2` вашего
репозитория и добавить его в solution папку `src/lab-2`. Данный сервис имеет Swagger документацию (по пути `/swagger`)
которую вы можете использовать для сидинга данных в сервис.

### Функциональные требования

- Реализация должна содержать [основной] интерфейс, позволяющий выгрузить все конфигурации из сервиса

### Нефункциональные требования

- Вам необходимо сделать две реализации – одну с ручной реализацией запросов, другую с использованием Refit
- Выгрузка конфигураций должна происходить пагинированно
- Основной интерфейс не должен зависеть от Refit
- Размер выгружаемой страницы должен параметризироваться
- В ручной реализации `HttpClient` должен получаться при помощи `IHttpClientFactory`
- Реализация должна содержать экстеншен методы для регистрации в DI обеих реализаций (два отдельных метода)

## Задание 2

### Отрабатываемый материал

Microsoft.Extensions.Configuration, ConfigurationProvider

### Задача

Реализовать кастомный ConfigurationProvider, который будет получать и отдавать конфигурации из сервиса Задания 1.

### Нефункциональные требования

- Вам необходимо реализовать сервис, обслуживающий провайдер, получающий конфигурации из клиента и отправляющий их в
  провайдер на обработку
- Сам провайдер не должен реализовывать какие-либо походы в клиенты
- Обслуживающий сервис должен предоставлять метод, обновляющий конфигурации раз в какой-то промежуток (для этого можно
  использовать класс PeriodicTimer)
- Промежуток обновления конфигураций должен быть параметризуем
- Провайдер не должен перезагружать конфигурации, если в них не было изменений

### Тестовые сценарии

#### Сценарий 1

**Arrange**: провайдер не имеет каких-либо ключей конфигураций
**Act**: провайдеру передают элемент конфигурации
**Assert**: провайдер содержит единственную пару ключ-значение, соответсвующую переданному элементу и обновляет
конфигурацию

#### Сценарий 2

**Arrange**: провайдер содержит единственную пару ключ-значение
**Act**: провайдеру передают такой же элемент конфигурации
**Assert**: провайдер не вызвал обновление конфигурации

#### Сценарий 3

**Arrange**: провайдер содержит единственную пару ключ-значение
**Act**: провайдеру передают элемент с таким же ключом, но изменённым значением
**Assert**: провайдер обновляет значение по ключу, и обновляет конфигурацию

#### Сценарий 4

**Arrange**: провайдер содержит единственную пару ключ-значение
**Act**: провайдеру передают пустую коллекцию конфигураций
**Assert**: провайдер становится пустым и обновляет конфигурацию

> для проверок того, обновил ли провайдер конфигурацию, вы можете посмотреть реализацию метода `OnReload` и какие данные
> он меняет

## Задание 3

### Отрабатываемый материал

Npgsql, Postgres, serialization, options

### Задание

Реализовать репозитории, миграцию и сервис для предоставленной [схемы данных](lab-2-task-3.sql).

### Функциональные требования

- Репозиторий товаров должен предоставлять функционал
    - Создания товаров
    - Пагинированного поиска товаров (фильтрация по: идентификаторам, минимальной и максимальной цене, подстроке в имени
      товара)
- Репозиторий заказов должен предоставлять функционал
    - Создания заказа
    - Изменения статуса заказа
    - Пагинированного поиска заказов (фильтрация по: идентификаторам, статусу, автору)
- Репозиторий позиций заказов должен предоставлять функционал
    - Добавление позиции заказа
    - Удаление позиции из заказа (soft delete)
    - Пагинированного поиска по позициям заказов (фильтрация по: идентификаторам заказов, идентификаторам товаров,
      признаку удаления [bool?])
- Репозиторий истории заказов должен предоставлять функционал
    - Добавление записи в историю заказа
    - Пагинированного поиска по истории заказов (фильтрация по: идентификаторам заказа, типу истории)
- Сервис товаров должен предоставлять функционал
    - Создания товаров
- Сервис заказов должен предоставлять функционал
    - Создания заказа
    - Добавления товаров в заказ (только для заказов в статусе `created`)
    - Удаление товаров из заказа (только для заказов в статусе `created`)
    - Перевод заказа в работу (статус `processing`)
    - Выполнение заказа (перевод в статус `completed`)
    - Отмену заказа (перевод в статус `cancelled`)
    - Пагинированного поиска по истории одного заказа
    - Все операции должны сопровождаться соответствующими записями в историю

### Нефункциональные требования

- Миграции должны быть реализованы через библиотеку FluentMigrator и SQL код
- Конфигурации базы данных должны быть получены через Microsoft.Extensions.Options
- Должны быть реализованы методы расширения для регистрации в DI миграций, репозиториев и подключений к базе данных
- Должен быть реализованы методы расширения для запуска миграций
- В репозитории истории заказов должна быть реализована полиморфная сериализация/десериализация записей истории (через System.Text.Json)
- Репозитории должны быть реализованы через SQL запросы и библиотеку Npgsql
- Операции сервиса, подразумевающие несколько запросов в базу данных, должны использовать транзакции
- Должен быть реализован метод расширения для регистрации сервисов в DI
- Конфигурация базы данных должна получаться из провайдера, реализованного в Задании 2

### Тестовые сценарии

В качестве тестового сценария реализуйте отдельное консольное приложение, собирающее ServiceCollection с реализованными
ранее сервисами, подключенной конфигурацией внешнего сервиса. Данные для подключения внешнего сервиса конфигураций
должны находится в JSON файле, также подключаемым в конфигурации.

Проект с данным сценарием должен находиться в solution папке тестов.

Для вашего сценария должна использоваться **отдельная** база данных (не та, что использует сервис конфигураций), для
этого вам будет необходимо добавить в docker compose файл ещё один сервис с базой данных.

Сценарий подразумевает

- Загрузку конфигураций через обслуживающий сервис
- Создание нескольких товаров
- Создание заказа
- Добавления товаров в заказ
- Удаление одного товара из заказа
- Перевод заказа в работу
- Выполнение заказа
- Вывод в консоль всей истории заказа

Работоспособность данного сценария вам необходимо будет продемонстрировать преподавателю на защите лабораторной.

# Лабораторная 3

## Отрабатываемый материал

ASP.NET, hosted service, http endpoints

## Задача

Интегрировать реализованный в Лабораторной 2 функционал в ASP.NET приложение.

- подключить все сервисы и конфигурации в ASP.NET хост
- перенести сервис обслуживающий конфигурации в фоновый сервис
- перенести запуск миграций в фоновый сервис
- добавить HTTP эндпоинты для операций сервисов

## Нефункциональные требования

- конфигурация из кастомного провайдера должна загружаться до запуска самого приложения
- код в Program.cs не должен явно выполнять какие-либо операции, он должен состоять только из настройки
  `builder.Services`, `builder.Configuration`, `app`
- должен быть реализован обработчик исключений для всех эндпоинтов, возвращающий сообщения ошибок в определённом формате
- сервис должен иметь Swagger документацию
- все эндпоинты должны иметь описание возможных кодов в Swagger документации

> Модифицировать код из второй лабораторной – разрешается



# Лабораторная 4

## Отрабатываемый материал

Явное межсервисное взаимодействие, gRPC

## Задача

Реализовать gRPC API для сервиса из Лабораторной 3, а также HTTP гейтвей для него.

- добавить gRPC API для сервиса заказов
- добавить отдельное ASP.NET приложение переадресующее – HTTP гейтвей
- HTTP гейтвей должен подключать клиент к gRPC сервису

## Нефункциональные требования

- конфигурация клиента должна происходить через Options
- модели gRPC API, подразумевающие полиморфизм, должны быть реализованы через `oneof`
- HTTP гейтвей должен иметь Swagger документацию
- все эндпоинты должны иметь описание возможных кодов в Swagger документации, а также описание возможных типов
  полиморфных моделей
- модели, подразумевающие полиморфизм, в API HTTP гейтвея должны быть реализованы **НЕ** в виде `oneof`
- должен быть реализован серверный Interceptor, отдающий сообщения об ошибках в определённом формате
- в HTTP гейтвее должен быть реализован middleware, для преобразование gRPC эксепшенов в конкретные HTTP коды

---


# Лабораторная 5

## Отрабатываемый материал

Реактивное межсервисное взаимодействие, Kafka

## Задача

Интегрировать сервис из Лабораторной 4 с сервисом обработки заказов.

- начать писать в топик `order_creation`
- начать читать топик `order_processing`
- добавить эндпоинты сервиса обработки заказа на гейтвей

Для развертывания сервиса используйте
файл [docker-compose.yaml](https://github.com/is-csms-y26/lab-5-tools/blob/master/docker-compose.yaml), он запускает
контейнер сервиса, его базу, kafka, а также kafka-ui, который вы можете использовать для просмотра сообщений в топиках и
отладки.

Для подключения к kafka вы должны использовать адрес `localhost:8001` если запускаете сервис не в docker контейнере.
Если вы запускаете свой сервис в docker контейнере, то вы должны добавить к нему нетворк
`order-processing-service-network` и использовать адрес `kafka:9094`.

Обратите внимание, что в данном файле, для конфигурации proto контрактов в kafka-ui используется путь относительный в
репозитории самого сервиса. Вам будет необходимо изменить этот путь на корректный для вашего репозитория.

```yaml
kafka-ui:
  # ...
  volumes:
    - ./src/Presentation/Lab5.Tools.Presentation.Kafka/protos:/schemas # change path to your local proto directory, ex: `src/lab-5/Kafka/protos:/schemas`
  # ...
```

Данная лабораторная должна быть реализована в папке `lab-4`, все необходимые модификации должны быть выполнены в
существующем коде. Допускается перенос реализаций сервисов и репозиториев в папку `lab-4`.

### Контракты

Схема топика
`order_creation` – [order_creation.proto](https://github.com/is-csms-y26/lab-5-tools/blob/master/src/Presentation/Lab5.Tools.Presentation.Kafka/protos/order_creation.proto)

Схема топика
`order_processing` – [order_processing.proto](https://github.com/is-csms-y26/lab-5-tools/blob/master/src/Presentation/Lab5.Tools.Presentation.Kafka/protos/order_processing.proto)

Контракты сервиса обработки
заказов – [orders.proto](https://github.com/is-csms-y26/lab-5-tools/blob/master/src/Presentation/Lab5.Tools.Presentation.Grpc/protos/orders.proto)

## Функциональные требования

- Ваш сервис должен читать топик `order_processing` и корректно обрабатывать его события
    - события, подразумевающие неудачный исход, при этом неудачном исходе должны переводить заказ в статус отменён в
      вашем сервисе
    - при получении событий о жизненном цикле заказа, ваш сервис должен записывать данные об этом в историю
- Ваш сервис должен писать в топик `order_creation` корректно обрабатывая свои операции
    - создание заказа должно приводить к записи сообщения об этом
    - перевод заказа в статус `processing` должен приводить к записи сообщения об этом
- Логика отмены заказов вашего сервиса должна быть переработана так, чтобы отмена была возможно только для заказов в
  статусе `created`
- После получения события об успешном завершении доставки заказа – заказ должен оказаться в статусе `completed`
- Вы должны убрать возможность перевести заказ в статус `completed` через ручки вашего сервиса

### Сценарий тестирования

- создание заказа (ваш сервис)
- перевод заказа в статус processing (ваш сервис)
- заказ согласуется* (сервис обработки заказов)
- начало упаковки заказа (сервис обработки заказов)
- завершение упаковки заказа* (сервис обработки заказов)
- начало доставки заказа (сервис обработки заказов)
- завершение доставки заказа* (сервис обработки заказов)

\* Данные операции сервиса обработки заказов могут завершиться неуспешно, ваш сервис должен уметь это обрабатывать.

## Нефункциональные требования

- Вы должны реализовать общие абстракции для записи в топики и чтения из них
    - для producer вы должны выделить интерфейс и реализовать его
    - для consumer вы должны выделить интерфейс обработчика сообщений, а также реализовать фоновый сервис вычитывающий
      сообщения
    - producer и consumer не должны завязываться на конкретные топики, они должны быть реализованы в отдельном проекте,
      должны иметь методы расширения для подключения
    - все параметры работы с kafka (подключение, названия топиков, размеры батчей) должны быть параметризованы через
      options
    - consumer должен реализовывать батчовую обработку сообщений
- В качестве примера реализации producer и consumer вы можете использовать
  библиотеку [Itmo.Dev.Platform.Kafka](https://github.com/itmo-is-dev/platform/tree/master/src/Itmo.Dev.Platform.Kafka)
- Запрещается использовать `Itmo.Dev.Platform.Kafka` в своем коде
- Запрещается полностью копировать реализацию из `Itmo.Dev.Platform.Kafka`
- Эндпоинты HTTP гейтвея, как новые, так и существующие, должны быть реализованы согласно конвенциям REST
